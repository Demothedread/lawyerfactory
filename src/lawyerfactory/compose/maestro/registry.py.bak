# Script Name: registry.py
# Description: Agent registry and coordination system for the LawyerFactory orchestration. Manages specialized bots and their lifecycle.
# Relationships:
#   - Entity Type: Module
#   - Directory Group: Orchestration
#   - Group Tags: orchestration
Agent registry and coordination system for the LawyerFactory orchestration.
Manages specialized bots and their lifecycle.
"""

import asyncio
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Type

from .workflow_models import PhaseStatus, WorkflowPhase, WorkflowTask

logger = logging.getLogger(__name__)


class AgentCapability(Enum):
    """Agent capabilities for task assignment"""
    DOCUMENT_INGESTION = "document_ingestion"
    TEXT_EXTRACTION = "text_extraction"
    LEGAL_RESEARCH = "legal_research"
    CASE_ANALYSIS = "case_analysis"
    LEGAL_WRITING = "legal_writing"
    DOCUMENT_REVIEW = "document_review"
    FORMATTING = "formatting"
    ORCHESTRATION = "orchestration"
    # AI-specific capabilities for document generation
    AI_CASE_CLASSIFICATION = "ai_case_classification"
    PDF_FORM_PROCESSING = "pdf_form_processing"
    AUTOMATED_FIELD_MAPPING = "automated_field_mapping"
    COURT_FORM_GENERATION = "court_form_generation"


@dataclass
class AgentConfig:
    """Configuration for agent instances"""
    agent_type: str
    max_concurrent: int = 1
    timeout_seconds: int = 300
    retry_attempts: int = 3
    capabilities: Optional[List[AgentCapability]] = None
    config: Optional[Dict[str, Any]] = None

    def __post_init__(self):
        if self.capabilities is None:
            self.capabilities = []
        if self.config is None:
            self.config = {}


class AgentInterface(ABC):
    """Base interface for all specialized agents"""

    def __init__(self, config: AgentConfig):
        # Accept plain dicts for convenience in tests and backwards compatibility
        if isinstance(config, dict):
            try:
                # Try direct construction first (preferred)
                try:
                    config = AgentConfig(**config)
                except TypeError:
                    # Some callers pass extra/legacy keys (e.g. 'agent_id', 'name', 'log_level').
                    # Filter known AgentConfig dataclass fields and preserve unknown keys under
                    # config.config['meta'] so we don't lose helpful metadata.
                    allowed = set(AgentConfig.__dataclass_fields__.keys())
                    filtered = {k: v for k, v in config.items() if k in allowed}
                    extra = {k: v for k, v in config.items() if k not in allowed}

                    config = AgentConfig(**filtered)
                    if extra:
                        if config.config is None:
                            config.config = {}
                        meta = config.config.get('meta', {})
                        meta.update(extra)
                        config.config['meta'] = meta
                        logger.debug(f"AgentInterface received extra config keys and stored under config.meta: {list(extra.keys())}")
            except Exception as e:
                raise TypeError(f"Invalid config dict for AgentInterface: {e}")

        self.config = config
        self.agent_type = config.agent_type
        self.is_busy = False
        self.current_task_id: Optional[str] = None

    @abstractmethod
    async def execute_task(self, task: WorkflowTask, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a specific task with given context"""
        pass

    @abstractmethod
    async def health_check(self) -> bool:
        """Check if the agent is healthy and ready to process tasks"""
        pass

    @abstractmethod
    async def initialize(self) -> None:
        """Initialize the agent with required resources"""
        pass

    @abstractmethod
    async def cleanup(self) -> None:
        """Clean up agent resources"""
        pass

    async def can_handle_task(self, task: WorkflowTask) -> bool:
        """Check if this agent can handle the given task"""
        # Base implementation checks capabilities
        required_capability = self._get_required_capability(task)
        if not self.config.capabilities:
            return False
        return required_capability in self.config.capabilities

    def _get_required_capability(self, task: WorkflowTask) -> AgentCapability:
        """Map task to required capability"""
        capability_map = {
            WorkflowPhase.INTAKE: AgentCapability.DOCUMENT_INGESTION,
            WorkflowPhase.OUTLINE: AgentCapability.CASE_ANALYSIS,
            WorkflowPhase.RESEARCH: AgentCapability.LEGAL_RESEARCH,
            WorkflowPhase.DRAFTING: AgentCapability.LEGAL_WRITING,
            WorkflowPhase.LEGAL_REVIEW: AgentCapability.DOCUMENT_REVIEW,
            WorkflowPhase.EDITING: AgentCapability.DOCUMENT_REVIEW,
            WorkflowPhase.ORCHESTRATION: AgentCapability.ORCHESTRATION,
        }
        
        # Check for AI-specific task types
        task_description = task.description.lower() if hasattr(task, 'description') else ""
        task_input_data = getattr(task, 'input_data', {})
        task_type = task_input_data.get('task_type', '')
        
        # Map AI-specific tasks to capabilities
        if 'ai_case_classification' in task_description or task_type == 'ai_case_classification':
            return AgentCapability.AI_CASE_CLASSIFICATION
        elif 'pdf_form_processing' in task_description or task_type == 'pdf_form_processing':
            return AgentCapability.PDF_FORM_PROCESSING
        elif 'automated_field_mapping' in task_description or task_type == 'automated_field_mapping':
            return AgentCapability.AUTOMATED_FIELD_MAPPING
        elif 'court_form_generation' in task_description or task_type == 'court_form_generation':
            return AgentCapability.COURT_FORM_GENERATION
        return capability_map.get(task.phase, AgentCapability.ORCHESTRATION)


class MockAgentInterface(AgentInterface):
    """Mock agent implementation for testing and development"""

    async def execute_task(self, task: WorkflowTask, context: Dict[str, Any]) -> Dict[str, Any]:
        """Mock task execution - returns a simulated result"""
        logger.info(f"Mock {self.agent_type} executing task {task.id}: {task.description}")
        
        # Simulate variable processing time depending on priority
        try:
            base_delay = 0.5
            if getattr(task, "priority", None) is not None:
                # map priority enum/int to delays conservatively
                base_delay += 0.2 * (getattr(task, "priority").value if hasattr(task.priority, "value") else 1)
        except Exception:
            base_delay = 1.0

        await asyncio.sleep(min(base_delay, 5))

        # Provide mock outputs tailored to task type / phase
        try:
            input_data = getattr(task, "input_data", {}) or {}
            task_type = input_data.get("task_type", "")
            description = (getattr(task, "description", "") or "").lower()

            # AI-specific behaviors
            if task_type == "ai_case_classification" or "ai case classification" in description:
                result = {
                    "classification": "contract_dispute",
                    "confidence": 0.87,
                    "context_updates": {"case_type": "contract_dispute"},
                    "entities": [{"id": "e1", "type": "LEGAL_ISSUE", "name": "Breach of Contract", "confidence": 0.92}]
                }
                return result

            if task_type == "pdf_form_processing" or "pdf form" in description:
                result = {
                    "forms_found": ["civil_complaint_form.pdf"],
                    "pages_processed": 3,
                    "context_updates": {"forms_detected": True},
                    "entities": []
                }
                return result

            if task_type == "automated_field_mapping" or "field mapping" in description:
                result = {
                    "field_mappings": {"plaintiff_name": "John Doe", "defendant_name": "Acme LLC"},
                    "confidence": 0.78,
                    "context_updates": {"field_mapping_complete": True}
                }
                return result

            if task_type == "court_form_generation" or "court form generation" in description:
                result = {
                    "generated_forms": [{"filename": "filled_complaint.pdf", "size_bytes": 123456}],
                    "requires_human_review": True,
                    "context_updates": {"forms_ready_for_review": True}
                }
                return result

            # Phase-based mock outputs
            if task.phase == WorkflowPhase.INTAKE:
                return {
                    "entities": [
                        {"id": "p1", "type": "PERSON", "name": "Jane Plaintiff", "confidence": 0.95},
                        {"id": "o1", "type": "ORGANIZATION", "name": "Doe & Co", "confidence": 0.88}
                    ],
                    "relationships": [],
                    "stats": {"pages": 10, "entities_extracted": 2},
                    "context_updates": {"intake_processed": True}
                }

            if task.phase == WorkflowPhase.RESEARCH:
                return {
                    "research_results": [
                        {"source": "CaseLawDB", "snippet": "Relevant ruling ...", "score": 0.82}
                    ],
                    "context_updates": {"research_collected": True}
                }

            if task.phase == WorkflowPhase.DRAFTING:
                return {
                    "document_text": "DRAFT: Plaintiff alleges ...",
                    "tokens_used": 512,
                    "context_updates": {"draft_ready": True}
                }

            if task.phase in (WorkflowPhase.LEGAL_REVIEW, WorkflowPhase.EDITING):
                return {
                    "issues_found": [],
                    "suggestions": ["Minor citation fix"],
                    "context_updates": {"review_passed": True}
                }

            # Default fallback
            return {"result": f"Mock execution completed for {task.id}", "context_updates": {}}

        except Exception as e:
            logger.error(f"MockAgent execution error for task {task.id}: {e}")
            raise

    async def health_check(self) -> bool:
        """Mock health check - always returns True"""
        return True

    async def initialize(self) -> None:
        """Mock initialization"""
        logger.info(f"Initialized mock {self.agent_type} agent")

    async def cleanup(self) -> None:
        """Mock cleanup"""
        logger.info(f"Cleaned up mock {self.agent_type} agent")


class AgentLoadBalancer:
    """Manages load balancing across agent instances"""

    def __init__(self):
        self.usage_metrics: Dict[str, int] = {}

    def select_agent(self, agents: List[AgentInterface]) -> AgentInterface:
        """Select the best available agent based on load"""
        if not agents:
            raise ValueError("No agents available")

        # Find the least busy agent
        available_agents = [agent for agent in agents if not agent.is_busy]
        if not available_agents:
            # If all busy, return the one with lowest usage
            return min(agents, key=lambda a: self.usage_metrics.get(a.agent_type, 0))

        # Return the least used available agent
        return min(available_agents, key=lambda a: self.usage_metrics.get(a.agent_type, 0))

    def record_usage(self, agent_type: str):
        """Record agent usage for load balancing"""
        self.usage_metrics[agent_type] = self.usage_metrics.get(agent_type, 0) + 1


class AgentRegistry:
    """Registry for managing specialized agents"""

    def __init__(self):
        self.agents: Dict[str, Dict[str, Any]] = {}
        self.agent_configs: Dict[str, AgentConfig] = {}
        self.load_balancer = AgentLoadBalancer()
        self._initialize_default_agents()

    def _initialize_default_agents(self):
        """Initialize default mock agents for all phases"""
        default_agents = [
            AgentConfig(
                agent_type="ReaderBot",
                capabilities=[AgentCapability.DOCUMENT_INGESTION, AgentCapability.TEXT_EXTRACTION],
                max_concurrent=2
            ),
            AgentConfig(
                agent_type="ParalegalBot",
                capabilities=[AgentCapability.CASE_ANALYSIS, AgentCapability.DOCUMENT_REVIEW],
                max_concurrent=3
            ),
            AgentConfig(
                agent_type="OutlinerBot",
                capabilities=[AgentCapability.CASE_ANALYSIS],
                max_concurrent=1
            ),
            AgentConfig(
                agent_type="ResearchBot",
                capabilities=[AgentCapability.LEGAL_RESEARCH],
                max_concurrent=2
            ),
            AgentConfig(
                agent_type="LegalResearcherBot",
                capabilities=[AgentCapability.LEGAL_RESEARCH],
                max_concurrent=2
            ),
            AgentConfig(
                agent_type="WriterBot",
                capabilities=[AgentCapability.LEGAL_WRITING],
                max_concurrent=1
            ),
            AgentConfig(
                agent_type="LegalFormatterBot",
                capabilities=[AgentCapability.FORMATTING, AgentCapability.DOCUMENT_REVIEW],
                max_concurrent=2
            ),
            AgentConfig(
                agent_type="LegalProcedureBot",
                capabilities=[AgentCapability.DOCUMENT_REVIEW],
                max_concurrent=1
            ),
            AgentConfig(
                agent_type="EditorBot",
                capabilities=[AgentCapability.DOCUMENT_REVIEW],
                max_concurrent=1
            ),
            AgentConfig(
                agent_type="MaestroBot",
                capabilities=[AgentCapability.ORCHESTRATION],
                max_concurrent=1
            ),
            AgentConfig(
                agent_type="AIDocumentAgent",
                capabilities=[
                    AgentCapability.AI_CASE_CLASSIFICATION,
                    AgentCapability.PDF_FORM_PROCESSING,
                    AgentCapability.AUTOMATED_FIELD_MAPPING,
                    AgentCapability.COURT_FORM_GENERATION,
                    AgentCapability.LEGAL_WRITING
                ],
                max_concurrent=2,
                timeout_seconds=600,
                config={
                    'forms_directory': 'docs/Court_files',
                    'output_directory': 'output',
                    'max_retries': 3,
                    'processing_timeout': 300
                }
            ),
        ]

        # Register real agents when available, fallback to mock agents
        for config in default_agents:
            real_agent_class = None
            
            # Try to import and use real agents
            try:
                if config.agent_type == "AIDocumentAgent":
                    from .bots.ai_document_agent import AIDocumentAgent
                    real_agent_class = AIDocumentAgent
                    logger.info(f"✓ AIDocumentAgent properly inherits from AgentInterface: {issubclass(AIDocumentAgent, AgentInterface)}")
                elif config.agent_type == "ResearchBot":
                    from .bots.research_bot import ResearchBot
                    real_agent_class = ResearchBot
                    logger.info(f"✓ ResearchBot properly inherits from AgentInterface: {issubclass(ResearchBot, AgentInterface)}")
                elif config.agent_type == "WriterBot":
                    from .bots.writer_bot import WriterBot
                    real_agent_class = WriterBot
                    logger.warning(f"⚠ WriterBot inheritance check - inherits from AgentInterface: {issubclass(WriterBot, AgentInterface)}")
                    logger.warning(f"⚠ WriterBot MRO: {WriterBot.__mro__}")
                elif config.agent_type == "EditorBot" or config.agent_type == "LegalFormatterBot":
                    from .bots.legal_editor import LegalEditorBot
                    real_agent_class = LegalEditorBot
                    logger.warning(f"⚠ LegalEditorBot inheritance check - inherits from AgentInterface: {issubclass(LegalEditorBot, AgentInterface)}")
                    logger.warning(f"⚠ LegalEditorBot MRO: {LegalEditorBot.__mro__}")
                elif config.agent_type == "LegalProcedureBot":
                    from .bots.legal_procedure_bot import LegalProcedureBot
                    real_agent_class = LegalProcedureBot
                    logger.info(f"✓ LegalProcedureBot properly inherits from AgentInterface: {issubclass(LegalProcedureBot, AgentInterface)}")
                elif config.agent_type == "MaestroBot":
                    from .bots.maestro_bot import MaestroBot
                    real_agent_class = MaestroBot
                    logger.info(f"✓ MaestroBot properly inherits from AgentInterface: {issubclass(MaestroBot, AgentInterface)}")
                elif config.agent_type == "ReaderBot":
                    from .bots.reader_bot import ReaderBot
                    real_agent_class = ReaderBot
                    logger.info(f"✓ ReaderBot properly inherits from AgentInterface: {issubclass(ReaderBot, AgentInterface)}")
                
                if real_agent_class and issubclass(real_agent_class, AgentInterface):
                    self.register_agent(config.agent_type, real_agent_class, config)
                    logger.info(f"✅ Registered real {config.agent_type} agent (proper AgentInterface)")
                else:
                    # Use mock agent for agent types without real implementations or improper inheritance
                    self.register_agent(config.agent_type, MockAgentInterface, config)
                    logger.error(f"❌ Using mock agent for {config.agent_type} - does not inherit from AgentInterface properly")
                    
            except ImportError as e:
                logger.warning(f"{config.agent_type} not available ({e}), using mock agent")
                self.register_agent(config.agent_type, MockAgentInterface, config)

    def register_agent(self, agent_type: str, agent_class: Type[AgentInterface], config: AgentConfig):
        """Register a new agent type"""
        self.agent_configs[agent_type] = config
        self.agents[agent_type] = {
            'class': agent_class,
            'instances': [],
            'max_concurrent': config.max_concurrent,
            'current_load': 0
        }
        logger.info(f"Registered agent type: {agent_type}")

    async def get_agent(self, agent_type: str) -> AgentInterface:
        """Get an available agent instance"""
        if agent_type not in self.agents:
            raise ValueError(f"Unknown agent type: {agent_type}")

        agent_info = self.agents[agent_type]
        config = self.agent_configs[agent_type]

        # Check if we can create a new instance
        if len(agent_info['instances']) < agent_info['max_concurrent']:
            instance = agent_info['class'](config)
            await instance.initialize()
            agent_info['instances'].append(instance)
            logger.info(f"Created new {agent_type} instance")
            return instance

        # Use load balancer to select best instance
        agent = self.load_balancer.select_agent(agent_info['instances'])
        self.load_balancer.record_usage(agent_type)
        return agent

    async def release_agent(self, agent: AgentInterface):
        """Release an agent after task completion"""
        agent.is_busy = False
        agent.current_task_id = None

    async def shutdown_all_agents(self):
        """Shutdown all agent instances"""
        for agent_type, agent_info in self.agents.items():
            for instance in agent_info['instances']:
                try:
                    await instance.cleanup()
                except Exception as e:
                    logger.error(f"Error cleaning up {agent_type}: {e}")
            agent_info['instances'].clear()
        logger.info("All agents shut down")

    def get_agent_status(self) -> Dict[str, Any]:
        """Get status of all registered agents"""
        status = {}
        for agent_type, agent_info in self.agents.items():
            status[agent_type] = {
                'instances': len(agent_info['instances']),
                'max_concurrent': agent_info['max_concurrent'],
                'current_load': agent_info['current_load'],
                'busy_instances': sum(1 for instance in agent_info['instances'] if instance.is_busy)
            }
        return status

    def get_agents_for_phase(self, phase: WorkflowPhase) -> List[str]:
        """Get list of agent types suitable for a specific phase"""
        # Agent assignment rules as defined in the specification
        phase_assignments = {
            WorkflowPhase.INTAKE: ['ReaderBot', 'ParalegalBot', 'AIDocumentAgent'],
            WorkflowPhase.OUTLINE: ['OutlinerBot', 'ParalegalBot'],
            WorkflowPhase.RESEARCH: ['ResearchBot', 'LegalResearcherBot'],
            WorkflowPhase.DRAFTING: ['WriterBot', 'ParalegalBot', 'AIDocumentAgent'],
            WorkflowPhase.LEGAL_REVIEW: ['LegalFormatterBot', 'LegalProcedureBot'],
            WorkflowPhase.EDITING: ['EditorBot'],
            WorkflowPhase.ORCHESTRATION: ['MaestroBot']
        }
        return phase_assignments.get(phase, [])


class TaskScheduler:
    """Intelligent task scheduling with dependency management"""

    def __init__(self, agent_registry: AgentRegistry):
        self.agent_registry = agent_registry

    def get_ready_tasks(self, workflow_state) -> List:
        """Get tasks that are ready to execute"""
        
        ready_tasks = []
        
        for task in workflow_state.tasks.values():
            if task.status == PhaseStatus.PENDING:
                if self._are_dependencies_satisfied(task, workflow_state):
                    if self._are_resources_available(task):
                        ready_tasks.append(task)

        # Sort by priority and phase order
        ready_tasks.sort(key=lambda t: (t.phase.value, -t.priority.value))
        
        return ready_tasks

    def _are_dependencies_satisfied(self, task, workflow_state) -> bool:
        """Check if all task dependencies are satisfied"""
        for dependency_id in task.depends_on:
            if dependency_id in workflow_state.tasks:
                dep_task = workflow_state.tasks[dependency_id]
                if dep_task.status != PhaseStatus.COMPLETED:
                    return False
        return True

    def _are_resources_available(self, task) -> bool:
        """Check if resources are available for the task"""
        # Check if appropriate agents are available for the task
        suitable_agents = self.agent_registry.get_agents_for_phase(task.phase)
        if not suitable_agents:
            return False
        
        # For now, assume resources are available if agents exist
        # In a more sophisticated implementation, this would check actual availability
        return True