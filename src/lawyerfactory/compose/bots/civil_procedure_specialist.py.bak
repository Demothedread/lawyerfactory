# Script Name: civil_procedure_specialist.py
# Description: Civil Procedure Specialist Agent for LawyerFactory Orchestration Phase.  This agent handles civil procedure requirements including: - Jurisdiction analysis and determination - Venue selection and validation - Service of process requirements - Pleading standards and requirements - Court filing procedures - Local rules compliance  The agent ensures that all procedural requirements are properly addressed in the legal documents and filings.
# Relationships:
#   - Entity Type: Module
#   - Directory Group: Orchestration
#   - Group Tags: null
Civil Procedure Specialist Agent for LawyerFactory Orchestration Phase.

This agent handles civil procedure requirements including:
- Jurisdiction analysis and determination
- Venue selection and validation
- Service of process requirements
- Pleading standards and requirements
- Court filing procedures
- Local rules compliance

The agent ensures that all procedural requirements are properly addressed
in the legal documents and filings.
"""

import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field

from ...compose.maestro.registry import AgentInterface, AgentCapability
from ...compose.maestro.workflow_models import WorkflowTask

logger = logging.getLogger(__name__)


@dataclass
class ProceduralRequirement:
    """Represents a civil procedure requirement"""
    requirement_type: str  # jurisdiction, venue, service, pleading, etc.
    description: str
    legal_basis: str
    status: str = "pending"  # pending, satisfied, issue
    details: Dict[str, Any] = field(default_factory=dict)


class CivilProcedureSpecialistAgent(AgentInterface):
    """Agent that handles civil procedure requirements"""

    def __init__(self, knowledge_graph=None):
        self.knowledge_graph = knowledge_graph
        self.capabilities = [AgentCapability.LEGAL_RESEARCH, AgentCapability.CASE_ANALYSIS]

        # Load procedural rules and requirements
        self._load_procedural_rules()

    def _load_procedural_rules(self):
        """Load civil procedure rules and requirements"""
        self.procedural_rules = {
            "jurisdiction": {
                "personal": "Defendant must have sufficient contacts with the forum state",
                "subject_matter": "Court must have authority to hear the type of case",
                "diversity": "Complete diversity of citizenship and amount in controversy > $75,000",
                "federal_question": "Case arises under federal law"
            },
            "venue": {
                "general": "Where defendant resides or where events occurred",
                "specific": "Statutory venue requirements for specific claim types",
                "transfer": "Change of venue standards and procedures"
            },
            "service_of_process": {
                "personal_service": "Direct delivery to defendant",
                "substituted_service": "Delivery to agent or family member",
                "service_by_mail": "Certified mail with return receipt",
                "publication": "When defendant cannot be located"
            },
            "pleading_standards": {
                "complaint": "Must state claim showing entitlement to relief",
                "twelve_b": "Specific defenses and motions to dismiss",
                "amendment": "Relation back and timing requirements"
            }
        }

    async def process(self, message: str) -> str:
        """Process a natural language request for civil procedure guidance"""
        try:
            # Analyze the request for procedural issues
            procedural_issues = self._analyze_procedural_request(message)

            # Generate procedural analysis
            analysis = await self.analyze_civil_procedure_requirements(procedural_issues)

            return analysis

        except Exception as e:
            logger.error(f"Error processing civil procedure request: {e}")
            return f"Error analyzing civil procedure requirements: {str(e)}"

    async def execute_task(self, task: WorkflowTask, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a workflow task related to civil procedure"""
        try:
            # Extract case information from context
            case_info = self._extract_case_information(context)

            # Analyze procedural requirements
            requirements = await self.analyze_procedural_requirements(case_info)

            # Generate procedural recommendations
            recommendations = self._generate_procedural_recommendations(requirements)

            return {
                "status": "completed",
                "requirements_analyzed": len(requirements),
                "requirements": [req.__dict__ for req in requirements],
                "recommendations": recommendations,
                "compliance_status": self._assess_compliance(requirements)
            }

        except Exception as e:
            logger.error(f"Error executing civil procedure task: {e}")
            return {
                "status": "failed",
                "error": str(e),
                "requirements_analyzed": 0,
                "requirements": [],
                "recommendations": [],
                "compliance_status": "unknown"
            }

    async def health_check(self) -> bool:
        """Check if the agent is functioning properly"""
        try:
            # Test basic functionality
            test_requirements = await self.analyze_procedural_requirements({"case_type": "contract_dispute"})
            return len(test_requirements) > 0
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return False

    async def initialize(self) -> None:
        """Initialize the agent"""
        try:
            logger.info("Civil Procedure Specialist Agent initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize Civil Procedure Specialist Agent: {e}")

    async def cleanup(self) -> None:
        """Clean up resources"""
        pass

    async def can_handle_task(self, task: WorkflowTask) -> bool:
        """Check if this agent can handle the given task"""
        task_text = f"{task.description} {task.agent_type}".lower()
        return any(keyword in task_text for keyword in [
            "jurisdiction", "venue", "procedure", "service", "pleading", "filing"
        ])

    async def analyze_procedural_requirements(self, case_info: Dict[str, Any]) -> List[ProceduralRequirement]:
        """Analyze civil procedure requirements for a case"""
        requirements = []

        # Jurisdiction analysis
        jurisdiction_reqs = await self._analyze_jurisdiction(case_info)
        requirements.extend(jurisdiction_reqs)

        # Venue analysis
        venue_reqs = await self._analyze_venue(case_info)
        requirements.extend(venue_reqs)

        # Service requirements
        service_reqs = await self._analyze_service_requirements(case_info)
        requirements.extend(service_reqs)

        # Pleading requirements
        pleading_reqs = await self._analyze_pleading_requirements(case_info)
        requirements.extend(pleading_reqs)

        return requirements

    async def analyze_civil_procedure_requirements(self, issues: List[str]) -> str:
        """Generate detailed analysis of civil procedure requirements"""
        analysis = "Civil Procedure Analysis:\n\n"

        for issue in issues:
            if "jurisdiction" in issue.lower():
                analysis += "JURISDICTION:\n"
                analysis += "- Personal Jurisdiction: Defendant must have sufficient contacts with the forum state\n"
                analysis += "- Subject Matter Jurisdiction: Court must have authority to hear this type of case\n"
                analysis += "- For federal court: Diversity jurisdiction or federal question\n"
                analysis += "- Amount in controversy must exceed $75,000 for diversity\n\n"

            elif "venue" in issue.lower():
                analysis += "VENUE:\n"
                analysis += "- General venue: Where defendant resides or where events occurred\n"
                analysis += "- Specific venue: Check statutory requirements for this claim type\n"
                analysis += "- Consider convenience of parties and witnesses\n"
                analysis += "- Forum non conveniens analysis if applicable\n\n"

            elif "service" in issue.lower():
                analysis += "SERVICE OF PROCESS:\n"
                analysis += "- Personal service preferred when possible\n"
                analysis += "- Substituted service allowed in some circumstances\n"
                analysis += "- Service by mail with waiver of service option\n"
                analysis += "- Publication service when defendant cannot be located\n\n"

        analysis += "RECOMMENDATIONS:\n"
        analysis += "1. Verify jurisdiction and venue before filing\n"
        analysis += "2. Ensure proper service of process\n"
        analysis += "3. Comply with local court rules\n"
        analysis += "4. Consider timing requirements and statutes of limitation\n"

        return analysis

    def _extract_case_information(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Extract relevant case information from context"""
        case_info = {
            "case_type": context.get("case_type", "general_civil"),
            "jurisdiction": context.get("jurisdiction", "state"),
            "defendant_location": context.get("defendant_location", "unknown"),
            "amount_in_controversy": context.get("amount_in_controversy", 0),
            "federal_question": context.get("federal_question", False),
            "parties": context.get("parties", [])
        }

        # Extract from claims if available
        claims = context.get("claims_matrix", {}).get("claims", [])
        if claims:
            case_info["claims"] = [claim.get("title", "") for claim in claims if isinstance(claim, dict)]

        return case_info

    async def _analyze_jurisdiction(self, case_info: Dict[str, Any]) -> List[ProceduralRequirement]:
        """Analyze jurisdiction requirements"""
        requirements = []

        jurisdiction = case_info.get("jurisdiction", "state")

        if jurisdiction == "federal":
            # Federal court requirements
            requirements.append(ProceduralRequirement(
                requirement_type="jurisdiction",
                description="Federal Subject Matter Jurisdiction",
                legal_basis="28 U.S.C. § 1332 (diversity) or § 1331 (federal question)",
                status="pending",
                details={"type": "federal_question" if case_info.get("federal_question") else "diversity"}
            ))

            # Amount in controversy for diversity
            amount = case_info.get("amount_in_controversy", 0)
            if amount < 75000:
                requirements.append(ProceduralRequirement(
                    requirement_type="jurisdiction",
                    description="Amount in Controversy Requirement",
                    legal_basis="28 U.S.C. § 1332",
                    status="issue",
                    details={"required": 75000, "actual": amount}
                ))

        else:
            # State court requirements
            requirements.append(ProceduralRequirement(
                requirement_type="jurisdiction",
                description="State Court Jurisdiction",
                legal_basis="State long-arm statute and due process",
                status="pending",
                details={"type": "general_jurisdiction"}
            ))

        return requirements

    async def _analyze_venue(self, case_info: Dict[str, Any]) -> List[ProceduralRequirement]:
        """Analyze venue requirements"""
        requirements = []

        defendant_location = case_info.get("defendant_location", "unknown")

        requirements.append(ProceduralRequirement(
            requirement_type="venue",
            description="Proper Venue Determination",
            legal_basis="28 U.S.C. § 1391 (federal) or state venue statutes",
            status="pending",
            details={"defendant_location": defendant_location}
        ))

        return requirements

    async def _analyze_service_requirements(self, case_info: Dict[str, Any]) -> List[ProceduralRequirement]:
        """Analyze service of process requirements"""
        requirements = []

        requirements.append(ProceduralRequirement(
            requirement_type="service",
            description="Service of Process Requirements",
            legal_basis="Fed. R. Civ. P. 4 (federal) or state rules",
            status="pending",
            details={"methods": ["personal", "substituted", "mail", "publication"]}
        ))

        return requirements

    async def _analyze_pleading_requirements(self, case_info: Dict[str, Any]) -> List[ProceduralRequirement]:
        """Analyze pleading requirements"""
        requirements = []

        requirements.append(ProceduralRequirement(
            requirement_type="pleading",
            description="Complaint Pleading Standards",
            legal_basis="Bell Atlantic Corp. v. Twombly, 550 U.S. 544 (2007)",
            status="pending",
            details={"standard": "plausibility", "rule_12b6": "failure_to_state_claim"}
        ))

        return requirements

    def _generate_procedural_recommendations(self, requirements: List[ProceduralRequirement]) -> List[str]:
        """Generate recommendations based on procedural requirements"""
        recommendations = []

        for req in requirements:
            if req.status == "issue":
                if "amount" in req.description.lower():
                    recommendations.append("Consider amending complaint to meet amount in controversy requirement")
                elif "jurisdiction" in req.requirement_type:
                    recommendations.append("Verify defendant's contacts with forum state")
                elif "venue" in req.requirement_type:
                    recommendations.append("Consider alternative venue options")

        # General recommendations
        recommendations.extend([
            "File proof of service with court",
            "Comply with local court rules for formatting",
            "Consider requesting waiver of service to save costs",
            "Keep copies of all filed documents"
        ])

        return recommendations

    def _assess_compliance(self, requirements: List[ProceduralRequirement]) -> str:
        """Assess overall compliance status"""
        issues = [req for req in requirements if req.status == "issue"]

        if not issues:
            return "compliant"
        elif len(issues) < len(requirements) * 0.5:
            return "partial_compliance"
        else:
            return "non_compliant"

    def _analyze_procedural_request(self, message: str) -> List[str]:
        """Analyze natural language request for procedural issues"""
        issues = []

        message_lower = message.lower()

        if "jurisdiction" in message_lower:
            issues.append("jurisdiction")
        if "venue" in message_lower:
            issues.append("venue")
        if "service" in message_lower:
            issues.append("service")
        if "pleading" in message_lower or "complaint" in message_lower:
            issues.append("pleading")
        if "filing" in message_lower:
            issues.append("filing")

        # Default to general analysis if no specific issues found
        if not issues:
            issues = ["jurisdiction", "venue", "service"]

        return issues