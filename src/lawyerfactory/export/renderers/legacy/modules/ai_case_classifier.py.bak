# Script Name: ai_case_classifier.py
# Description: AI-Powered Case Classification Module for LawyerFactory  This module analyzes case facts and classifies them into appropriate legal case types to enable intelligent form selection and document generation.
# Relationships:
#   - Entity Type: Module
#   - Directory Group: Document Generation
#   - Group Tags: null
AI-Powered Case Classification Module for LawyerFactory

This module analyzes case facts and classifies them into appropriate legal case types
to enable intelligent form selection and document generation.
"""

import logging
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple


class CaseType(Enum):
    """Enumeration of supported case types based on available court forms."""
    
    BREACH_OF_CONTRACT = "breach_of_contract"
    PERSONAL_INJURY = "personal_injury"
    NEGLIGENCE = "negligence"
    PROPERTY_DAMAGE = "property_damage"
    PRODUCT_LIABILITY = "product_liability"
    EMPLOYMENT = "employment"
    CONSUMER_PROTECTION = "consumer_protection"
    FRAUD = "fraud"
    DEFAMATION = "defamation"
    INTENTIONAL_TORT = "intentional_tort"
    UNKNOWN = "unknown"


@dataclass
class CaseClassification:
    """Result of case classification analysis."""
    
    primary_type: CaseType
    confidence: float  # 0.0 to 1.0
    secondary_types: List[Tuple[CaseType, float]]  # Alternative classifications
    reasoning: str
    key_indicators: List[str]
    damages_categories: List[str]
    urgency_level: str  # "low", "medium", "high"


class CaseClassifier:
    """
    AI-powered classifier that analyzes case facts and determines case types.
    
    This class uses pattern matching, keyword analysis, and legal reasoning
    to classify cases into appropriate categories for form selection.
    """
    
    def __init__(self):
        """Initialize the case classifier with legal patterns and indicators."""
        self.logger = logging.getLogger(__name__)
        
        # Define classification patterns and keywords
        self._initialize_classification_patterns()
        
    def _initialize_classification_patterns(self):
        """Initialize patterns and keywords for case type classification."""
        
        self.case_patterns = {
            CaseType.BREACH_OF_CONTRACT: {
                'keywords': [
                    'contract', 'agreement', 'breach', 'obligation', 'performance',
                    'terms', 'conditions', 'violation', 'default', 'non-performance',
                    'material breach', 'substantial performance', 'covenant',
                    'warranty', 'guarantee', 'promise', 'consideration'
                ],
                'phrases': [
                    'failed to perform', 'breach of contract', 'violated the agreement',
                    'did not comply with', 'material breach', 'anticipatory breach',
                    'partial performance', 'substantial performance'
                ],
                'legal_elements': [
                    'formation', 'performance', 'breach', 'damages'
                ]
            },
            
            CaseType.PERSONAL_INJURY: {
                'keywords': [
                    'injury', 'injured', 'hurt', 'harm', 'damage', 'accident',
                    'medical', 'hospital', 'treatment', 'surgery', 'disability',
                    'pain', 'suffering', 'physical', 'emotional', 'trauma',
                    'ambulance', 'emergency room', 'doctor', 'physician'
                ],
                'phrases': [
                    'personal injury', 'bodily injury', 'physical harm',
                    'serious injury', 'permanent disability', 'pain and suffering',
                    'medical expenses', 'lost wages', 'emotional distress'
                ],
                'legal_elements': [
                    'duty', 'breach of duty', 'causation', 'damages'
                ]
            },
            
            CaseType.NEGLIGENCE: {
                'keywords': [
                    'negligent', 'negligence', 'careless', 'reckless', 'duty',
                    'standard of care', 'reasonable', 'foreseeable', 'proximate',
                    'causation', 'fault', 'liability', 'responsible'
                ],
                'phrases': [
                    'acted negligently', 'failed to exercise', 'reasonable care',
                    'standard of care', 'proximate cause', 'foreseeable harm',
                    'duty of care', 'breach of duty'
                ],
                'legal_elements': [
                    'duty', 'breach', 'causation', 'damages'
                ]
            },
            
            CaseType.PRODUCT_LIABILITY: {
                'keywords': [
                    'product', 'defective', 'defect', 'manufacturing', 'design',
                    'warning', 'instructions', 'malfunction', 'dangerous',
                    'unsafe', 'recall', 'manufacturer', 'seller', 'distributor'
                ],
                'phrases': [
                    'defective product', 'product defect', 'design defect',
                    'manufacturing defect', 'failure to warn', 'product liability',
                    'unreasonably dangerous', 'strict liability'
                ],
                'legal_elements': [
                    'defect', 'unreasonably dangerous', 'causation', 'damages'
                ]
            },
            
            CaseType.PROPERTY_DAMAGE: {
                'keywords': [
                    'property', 'damage', 'destroyed', 'repair', 'replacement',
                    'building', 'house', 'car', 'vehicle', 'equipment',
                    'fire', 'flood', 'vandalism', 'destruction'
                ],
                'phrases': [
                    'property damage', 'damaged property', 'destruction of property',
                    'repair costs', 'replacement value', 'diminished value'
                ],
                'legal_elements': [
                    'ownership', 'damage', 'causation', 'valuation'
                ]
            },
            
            CaseType.EMPLOYMENT: {
                'keywords': [
                    'employment', 'employee', 'employer', 'workplace', 'job',
                    'fired', 'terminated', 'discrimination', 'harassment',
                    'wage', 'salary', 'overtime', 'benefits', 'wrongful'
                ],
                'phrases': [
                    'wrongful termination', 'workplace discrimination',
                    'sexual harassment', 'wage theft', 'overtime violations',
                    'hostile work environment', 'retaliation'
                ],
                'legal_elements': [
                    'employment relationship', 'violation', 'damages', 'protected class'
                ]
            },
            
            CaseType.FRAUD: {
                'keywords': [
                    'fraud', 'fraudulent', 'misrepresentation', 'deception',
                    'false', 'lie', 'conceal', 'omit', 'reliance', 'inducement'
                ],
                'phrases': [
                    'fraudulent misrepresentation', 'intentional deception',
                    'false statements', 'justifiable reliance', 'material fact'
                ],
                'legal_elements': [
                    'misrepresentation', 'intent', 'reliance', 'damages'
                ]
            }
        }
        
        # Damage type indicators
        self.damage_patterns = {
            'economic': ['lost wages', 'lost profits', 'medical expenses', 'repair costs', 'replacement cost'],
            'non_economic': ['pain and suffering', 'emotional distress', 'loss of enjoyment', 'consortium'],
            'punitive': ['willful', 'malicious', 'reckless', 'intentional', 'gross negligence']
        }
        
        # Urgency indicators
        self.urgency_patterns = {
            'high': ['statute of limitations', 'emergency', 'immediate', 'urgent', 'deadline'],
            'medium': ['ongoing', 'continuing', 'repeated', 'pattern'],
            'low': ['past', 'completed', 'resolved', 'settled']
        }
    
    def classify_case(self, case_facts: List[Dict[str, Any]], 
                     additional_context: Optional[Dict[str, Any]] = None) -> CaseClassification:
        """
        Classify a case based on the provided facts.
        
        Args:
            case_facts: List of fact dictionaries with 'text' and optional metadata
            additional_context: Optional additional context information
            
        Returns:
            CaseClassification object with analysis results
        """
        
        # Combine all fact text for analysis
        combined_text = " ".join([fact.get('text', '') for fact in case_facts if fact.get('text')])
        
        if not combined_text.strip():
            return CaseClassification(
                primary_type=CaseType.UNKNOWN,
                confidence=0.0,
                secondary_types=[],
                reasoning="No case facts provided for analysis",
                key_indicators=[],
                damages_categories=[],
                urgency_level="low"
            )
        
        # Normalize text for analysis
        normalized_text = combined_text.lower()
        
        # Score each case type
        type_scores = {}
        type_indicators = {}
        
        for case_type, patterns in self.case_patterns.items():
            score, indicators = self._score_case_type(normalized_text, patterns)
            type_scores[case_type] = score
            type_indicators[case_type] = indicators
        
        # Determine primary and secondary classifications
        sorted_scores = sorted(type_scores.items(), key=lambda x: x[1], reverse=True)
        
        if not sorted_scores or sorted_scores[0][1] == 0:
            primary_type = CaseType.UNKNOWN
            confidence = 0.0
            secondary_types = []
            key_indicators = []
        else:
            primary_type = sorted_scores[0][0]
            max_score = sorted_scores[0][1]
            
            # Calculate confidence based on score and gap to second place
            if len(sorted_scores) > 1:
                second_score = sorted_scores[1][1]
                confidence = min(max_score / 10.0, 1.0)  # Normalize to 0-1
                if max_score > second_score * 1.5:  # Clear winner
                    confidence = min(confidence * 1.2, 1.0)
            else:
                confidence = min(max_score / 10.0, 1.0)
            
            # Secondary classifications (threshold of 30% of primary score)
            threshold = max_score * 0.3
            secondary_types = [
                (case_type, score) for case_type, score in sorted_scores[1:]
                if score >= threshold
            ]
            
            key_indicators = type_indicators[primary_type]
        
        # Analyze damage types
        damages_categories = self._analyze_damages(normalized_text)
        
        # Determine urgency
        urgency_level = self._determine_urgency(normalized_text)
        
        # Generate reasoning
        reasoning = self._generate_reasoning(primary_type, confidence, key_indicators, damages_categories)
        
        return CaseClassification(
            primary_type=primary_type,
            confidence=confidence,
            secondary_types=secondary_types,
            reasoning=reasoning,
            key_indicators=key_indicators,
            damages_categories=damages_categories,
            urgency_level=urgency_level
        )
    
    def _score_case_type(self, text: str, patterns: Dict[str, List[str]]) -> Tuple[float, List[str]]:
        """Score how well the text matches a particular case type."""
        
        score = 0.0
        found_indicators = []
        
        # Score keywords
        for keyword in patterns['keywords']:
            if keyword in text:
                score += 1.0
                found_indicators.append(f"keyword: {keyword}")
        
        # Score phrases (higher weight)
        for phrase in patterns['phrases']:
            if phrase in text:
                score += 2.0
                found_indicators.append(f"phrase: {phrase}")
        
        # Score legal elements (highest weight)
        if 'legal_elements' in patterns:
            for element in patterns['legal_elements']:
                if element in text:
                    score += 3.0
                    found_indicators.append(f"element: {element}")
        
        return score, found_indicators
    
    def _analyze_damages(self, text: str) -> List[str]:
        """Analyze what types of damages are mentioned in the case."""
        
        damages = []
        
        for damage_type, indicators in self.damage_patterns.items():
            for indicator in indicators:
                if indicator in text:
                    if damage_type not in damages:
                        damages.append(damage_type)
                    break
        
        return damages
    
    def _determine_urgency(self, text: str) -> str:
        """Determine the urgency level of the case."""
        
        urgency_scores = {'high': 0, 'medium': 0, 'low': 0}
        
        for level, indicators in self.urgency_patterns.items():
            for indicator in indicators:
                if indicator in text:
                    urgency_scores[level] += 1
        
        # Return the urgency level with highest score, defaulting to medium
        max_urgency = max(urgency_scores.items(), key=lambda x: x[1])
        return max_urgency[0] if max_urgency[1] > 0 else 'medium'
    
    def _generate_reasoning(self, primary_type: CaseType, confidence: float, 
                          indicators: List[str], damages: List[str]) -> str:
        """Generate human-readable reasoning for the classification."""
        
        if primary_type == CaseType.UNKNOWN:
            return "Unable to classify case due to insufficient or unclear facts."
        
        reasoning_parts = [
            f"Classified as {primary_type.value} with {confidence:.1%} confidence."
        ]
        
        if indicators:
            top_indicators = indicators[:3]  # Show top 3 indicators
            reasoning_parts.append(f"Key indicators: {', '.join(top_indicators[:3])}.")
        
        if damages:
            reasoning_parts.append(f"Potential damages: {', '.join(damages)}.")
        
        if confidence < 0.6:
            reasoning_parts.append("Consider reviewing facts for additional clarity.")
        
        return " ".join(reasoning_parts)
    
    def get_supported_case_types(self) -> List[CaseType]:
        """Get list of all supported case types."""
        return list(self.case_patterns.keys())
    
    def suggest_additional_facts(self, classification: CaseClassification) -> List[str]:
        """Suggest additional facts that could improve classification confidence."""
        
        suggestions = []
        
        if classification.confidence < 0.7:
            if classification.primary_type != CaseType.UNKNOWN:
                case_type = classification.primary_type
                patterns = self.case_patterns[case_type]
                
                suggestions.append(f"Consider gathering more facts about {case_type.value}")
                
                if 'legal_elements' in patterns:
                    missing_elements = [
                        elem for elem in patterns['legal_elements']
                        if not any(elem in indicator for indicator in classification.key_indicators)
                    ]
                    if missing_elements:
                        suggestions.append(f"Focus on evidence of: {', '.join(missing_elements)}")
        
        if not classification.damages_categories:
            suggestions.append("Identify specific types of damages or harm suffered")
        
        return suggestions


def test_case_classifier():
    """Test function for CaseClassifier functionality."""
    
    classifier = CaseClassifier()
    
    # Test cases
    test_cases = [
        {
            'name': 'Tesla Contract Breach',
            'facts': [
                {'text': 'Tesla failed to deliver the vehicle on the agreed date specified in the purchase contract'},
                {'text': 'The contract clearly stated delivery would occur within 30 days of order'},
                {'text': 'Customer has suffered financial losses due to the breach of contract'}
            ]
        },
        {
            'name': 'Car Accident Injury',
            'facts': [
                {'text': 'Plaintiff was injured in a car accident caused by defendant\'s negligent driving'},
                {'text': 'Suffered broken bones and required surgery and physical therapy'},
                {'text': 'Incurred significant medical expenses and lost wages from work'}
            ]
        },
        {
            'name': 'Defective Product',
            'facts': [
                {'text': 'The product exploded during normal use causing injury'},
                {'text': 'Manufacturing defect in the battery system caused the explosion'},
                {'text': 'Company failed to provide adequate warnings about the danger'}
            ]
        }
    ]
    
    print("Testing Case Classifier:")
    print("=" * 50)
    
    for test_case in test_cases:
        print(f"\nTest Case: {test_case['name']}")
        print("-" * 30)
        
        classification = classifier.classify_case(test_case['facts'])
        
        print(f"Primary Type: {classification.primary_type.value}")
        print(f"Confidence: {classification.confidence:.1%}")
        print(f"Reasoning: {classification.reasoning}")
        
        if classification.secondary_types:
            print(f"Secondary Types: {[(t.value, f'{s:.1%}') for t, s in classification.secondary_types]}")
        
        if classification.damages_categories:
            print(f"Damage Types: {classification.damages_categories}")
        
        print(f"Urgency: {classification.urgency_level}")
        
        suggestions = classifier.suggest_additional_facts(classification)
        if suggestions:
            print(f"Suggestions: {suggestions}")


if __name__ == "__main__":
    # Enable logging for testing
    logging.basicConfig(level=logging.INFO)
    test_case_classifier()