<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Document Factory</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            color: #e5e7eb; /* gray-200 */
        }
        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }
        .node {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .node:hover > circle {
            stroke-width: 4px;
        }
        .link {
            stroke: #4b5563; /* gray-600 */
            stroke-opacity: 0.6;
        }
        .factor-doc { background-color: #3b82f6; color: white; padding: 2px 6px; border-radius: 4px; }
        .factor-key { background-color: #10b981; color: white; padding: 2px 6px; border-radius: 4px; }
        .factor-subkey { background-color: #f97316; color: white; padding: 2px 6px; border-radius: 4px; }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        .modal { transition: opacity 0.25s ease; }
        .modal-content { transition: transform 0.25s ease; }

        .agent-icon {
            font-size: 20px;
            fill: #e5e7eb;
        }
        .agent-circle {
            transition: all 0.2s ease-in-out;
        }
        .agent-circle:hover {
            stroke-width: 3px;
            stroke: #3b82f6;
        }
        .knob-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
    </style>
</head>
<body class="bg-gray-900 overflow-hidden h-screen">

    <div id="app" class="flex flex-col h-screen">
        <!-- Header -->
        <header class="bg-gray-800/50 backdrop-blur-sm border-b border-gray-700 p-4 flex justify-between items-center z-20">
            <h1 class="text-2xl font-bold text-white tracking-wide">The Document Factory</h1>
            <div class="flex items-center space-x-4">
                <select id="docTypeSelector" class="bg-gray-700 border border-gray-600 text-white rounded-md px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="business_proposal">Business Proposal</option>
                    <option value="legal_claim">Legal Claim</option>
                    <option value="white_paper">White Paper</option>
                </select>
                <button id="startButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200">
                    Start Production
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <main class="flex-grow grid grid-cols-1 lg:grid-cols-12 gap-4 p-4 overflow-hidden">
            
            <!-- Left Panel: Blueprint -->
            <div class="lg:col-span-3 bg-gray-800/50 rounded-lg p-6 shadow-lg flex flex-col overflow-y-auto space-y-4">
                <h2 class="text-xl font-semibold mb-4 text-white border-b border-gray-700 pb-2">Blueprint</h2>
                <div>
                    <label for="promptInput" class="block text-sm font-medium text-gray-300 mb-2">User Prompt</label>
                    <textarea id="promptInput" rows="4" class="w-full bg-gray-900 border border-gray-700 rounded-md p-2 text-sm text-gray-200 focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="Enter your document request here..."></textarea>
                    <div id="deconstructedPrompt" class="mt-4 p-3 bg-gray-900 rounded-md text-sm leading-relaxed min-h-[80px]"></div>
                </div>
                <!-- Instructions Box -->
                <div id="instructionBox" class="mt-6 flex-grow flex flex-col bg-gray-900/50 p-4 rounded-lg border border-gray-700">
                    <!-- Dynamic content will be injected here -->
                </div>
                <div id="roleDelineation" class="bg-gray-900/50 p-4 rounded-lg border border-gray-700"></div>
                <div id="researchChecklist" class="bg-gray-900/50 p-4 rounded-lg border border-gray-700"></div>
            </div>

            <!-- Center Panel: Factory Floor -->
            <div class="lg:col-span-6 bg-gray-800/50 rounded-lg shadow-lg flex flex-col overflow-hidden relative">
                <div class="flex items-center justify-between px-6 pt-6">
                    <h2 class="text-xl font-semibold text-white">Factory Floor</h2>
                    <div id="stageTimeline" class="grid grid-cols-2 lg:grid-cols-4 gap-2 w-2/3"></div>
                </div>
                <div class="px-6 pb-4 text-xs text-gray-400">Sequenced stages ensure OCR intake flows into shotlisting, legal research, and drafting.</div>
                <div id="factoryFloor" class="flex-grow w-full h-full"></div>
                <div id="factoryStatus" class="absolute bottom-4 left-4 bg-black/50 text-white text-xs font-mono p-2 rounded-md">STATUS: IDLE</div>
            </div>

            <!-- Right Panel: Final Product -->
            <div class="lg:col-span-3 bg-gray-800/50 rounded-lg shadow-lg flex flex-col overflow-y-auto">
                <h2 class="text-xl font-semibold p-6 text-white border-b border-gray-700">Final Product</h2>
                <div id="finalProduct" class="p-6 space-y-4 text-sm leading-relaxed"></div>
            </div>
        </main>
    </div>

    <!-- Modal for Node Details -->
    <div id="nodeModal" class="modal fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4 hidden opacity-0">
        <div id="modalContent" class="modal-content bg-gray-800 rounded-lg shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col transform scale-95">
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h3 id="modalTitle" class="text-lg font-bold text-white">Task Details</h3>
                <button id="closeModal" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div id="modalBody" class="p-6 overflow-y-auto text-gray-300"></div>
        </div>
    </div>

    <script>
        // --- ICONS ---
        const ICONS = {
            Maestro: `<path d="M12 2.5a5.5 5.5 0 0 1 3.096 10.047 9.005 9.005 0 0 1 5.9 8.198.75.75 0 0 1-1.492.154 7.505 7.505 0 0 0-14.998 0 .75.75 0 0 1-1.492-.154 9.005 9.005 0 0 1 5.9-8.198A5.5 5.5 0 0 1 12 2.5ZM8 8a4 4 0 1 0 8 0 4 4 0 0 0-8 0Z" />`,
            Planner: `<path d="M3.5 2.75a.75.75 0 0 0-1.5 0v14.5a.75.75 0 0 0 1.5 0v-1.168c1.333.477 2.745.618 4.25.25V18.5a.75.75 0 0 0 1.5 0v-2.086c.334.035.67.062 1 .077v2.259a.75.75 0 0 0 1.5 0v-2.5a.75.75 0 0 0-.75-.75h-.25c-.322 0-.64-.015-.95-.042V9.528c.271.026.54.04.81.04H12a.75.75 0 0 0 .75-.75V3.5a.75.75 0 0 0-1.5 0v1.44c-1.333-.477-2.745-.618-4.25-.25V2.75Zm4.25 2.502c1.25-.316 2.519-.234 3.75.25V7.5c-1.25.316-2.519.234-3.75-.25V5.252Z" />`,
            Researcher: `<path d="m16.704 15.182-2.855-2.855a6.002 6.002 0 1 0-1.522 1.522l2.855 2.855a1.076 1.076 0 1 0 1.522-1.522ZM10.5 15a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9Z" />`,
            Writer: `<path d="M19.903 8.586a3.491 3.491 0 0 0-4.939-4.938L3.515 15.097a1.047 1.047 0 0 0-.307.74V19.5a.5.5 0 0 0 .5.5h3.662c.284 0 .55-.116.74-.307L19.903 8.586Zm-5.68-3.442a1.991 1.991 0 0 1 2.817 2.817L15.6 9.4l-2.817-2.817 1.437-1.437Z" />`,
            Editor: `<path d="M14.623 2.236a2.75 2.75 0 0 1 3.89 3.89L9.29 15.348a2.75 2.75 0 0 1-1.572.792l-3.321.604a.75.75 0 0 1-.86-.86l.604-3.32a2.75 2.75 0 0 1 .792-1.572L14.623 2.236Zm1.879 1.878a1.25 1.25 0 0 0-1.768 0L6.5 12.348l-2.086 2.086 2.086-2.086.53-.53a1.25 1.25 0 1 0-1.768-1.768l-.53.53-2.086 2.086 2.086 2.086 8.234-8.234a1.25 1.25 0 0 0 0-1.768Z" />`,
            MarketAnalyst: `<path d="M4 2.5a.5.5 0 0 1 .5-.5h15a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5v-15Zm1.5 14v-5.5h2.5v5.5H5.5Zm3.5 0v-9h2.5v9H9Zm3.5 0v-7.5h2.5v7.5h-2.5Zm3.5 0v-11h2.5v11h-2.5Z" />`,
            FinancialModeler: `<path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm-5 7.5a.5.5 0 0 1 .5-.5h2.5a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5H7.5a.5.5 0 0 1-.5-.5v-5Zm4 0a.5.5 0 0 1 .5-.5h2.5a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5h-2.5a.5.5 0 0 1-.5-.5v-5Z" />`,
            LegalDrafter: `<path d="M12.75 3.5a.75.75 0 0 0-1.5 0V4h-1.5a.75.75 0 0 0 0 1.5h1.5v1.5a.75.75 0 0 0 1.5 0V5.5h1.5a.75.75 0 0 0 0-1.5h-1.5V3.5ZM9.5 2.5a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v18a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 .5-.5v-18Zm-1 17v-16h-1v16h1Z" />`,
            DataVisualizer: `<path d="M3 12a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v6.5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5V12Zm5 0a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v6.5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5V12Zm5-2a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v8.5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5V10Zm5-4.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v13a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-13Z" />`
        };

        // --- CONFIGURATION ---
        const API_BASE_URL =
            window.location.protocol === 'file:' || window.location.origin === 'null'
                ? 'http://localhost:8000'
                : window.location.origin;
        const DOC_TYPE_LABELS = {
            business_proposal: "Business Proposal",
            legal_claim: "Legal Claim",
            white_paper: "White Paper"
        };

        const AGENT_POOL = [
            { id: 'Maestro', role: 'Maestro', type: 'Orchestrator', icon: ICONS.Maestro },
            { id: 'PlannerAgent', role: 'Planner', type: 'Generalist', icon: ICONS.Planner },
            { id: 'WebResearchAgent', role: 'Researcher', type: 'Generalist', icon: ICONS.Researcher },
            { id: 'LegalResearchAgent', role: 'Legal Researcher', type: 'Specialist (CourtListener / LegiScan)', icon: ICONS.Researcher },
            { id: 'GeneralWriterAgent', role: 'Writer', type: 'Generalist', icon: ICONS.Writer },
            { id: 'EditorAgent', role: 'Editor', type: 'Generalist', icon: ICONS.Editor },
            { id: 'MarketAnalystAgent', role: 'Market Analyst', type: 'Specialist', icon: ICONS.MarketAnalyst },
            { id: 'FinancialModelerAgent', role: 'Financial Modeler', type: 'Specialist', icon: ICONS.FinancialModeler },
            { id: 'LegalDrafterAgent', role: 'Legal Drafter', type: 'Specialist', icon: ICONS.LegalDrafter },
            { id: 'DataVisualizationAgent', role: 'Data Visualizer', type: 'Specialist', icon: ICONS.DataVisualizer },
            { id: 'ShotlistAgent', role: 'Shotlist Builder', type: 'Specialist (Lex Omnia GPT)', icon: ICONS.Planner },
        ];

        const ROLE_DEFINITIONS = {
            legal_claim: [
                {
                    title: 'Shotlist vs. Legal Research',
                    bullet: 'Shotlist Agent reads OCR text to sequence facts, exhibits, and prompts into a production-ready outline before drafting.',
                },
                {
                    title: 'Legal Research Agent',
                    bullet: 'Searches CourtListener, LegiScan, and open legal sources to align statutes, elements, and caselaw factors with the facts.',
                },
                {
                    title: 'Claim Builder',
                    bullet: 'Tracks claim checklists element-by-element with citations so the drafter can assemble allegations confidently.',
                }
            ],
            default: [
                {
                    title: 'Shotlist Planner',
                    bullet: 'Turns the prompt and uploads into a structured outline before handing off to researchers and writers.',
                },
                {
                    title: 'Research Agent',
                    bullet: 'Pulls supporting facts and references from available sources before drafting.',
                }
            ]
        };

        /**
         * Build a request URL for the pipeline service.
         * @param {string} path
         * @returns {string}
         */
        function apiBuildUrl(path) {
            return `${API_BASE_URL}${path}`;
        }

        /**
         * POST /jobs to start a new pipeline job.
         * @param {Object} payload
         * @returns {Promise<Object>}
         */
        async function apiCreateJob(payload) {
            const response = await fetch(apiBuildUrl('/jobs'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                const errorBody = await response.json().catch(() => ({}));
                const errorDetail = errorBody.detail || 'Unknown error';
                throw new Error(`Unable to create job (status: ${response.status}): ${errorDetail}`);
            }
            return response.json();
        }

        /**
         * GET /jobs/{id} to retrieve job status.
         * @param {string} jobId
         * @returns {Promise<Object>}
         */
        async function apiFetchJob(jobId) {
            const response = await fetch(apiBuildUrl(`/jobs/${jobId}`));
            if (!response.ok) {
                const errorBody = await response.json().catch(() => ({}));
                const errorDetail = errorBody.detail || 'Unknown error';
                throw new Error(`Unable to fetch job (status: ${response.status}): ${errorDetail}`);
            }
            return response.json();
        }

        /**
         * GET /jobs/{id}/sections to retrieve drafted sections.
         * @param {string} jobId
         * @returns {Promise<Object>}
         */
        async function apiFetchSections(jobId) {
            const response = await fetch(apiBuildUrl(`/jobs/${jobId}/sections`));
            if (!response.ok) {
                const errorBody = await response.json().catch(() => ({}));
                const errorDetail = errorBody.detail || 'Unknown error';
                throw new Error(`Unable to fetch sections (status: ${response.status}): ${errorDetail}`);
            }
            return response.json();
        }
        
        // --- DOM ELEMENTS ---
        const docTypeSelector = document.getElementById('docTypeSelector');
        const startButton = document.getElementById('startButton');
        const promptInput = document.getElementById('promptInput');
        const deconstructedPrompt = document.getElementById('deconstructedPrompt');
        const instructionBox = document.getElementById('instructionBox');
        const roleDelineation = document.getElementById('roleDelineation');
        const researchChecklist = document.getElementById('researchChecklist');
        const factoryFloor = document.getElementById('factoryFloor');
        const factoryStatus = document.getElementById('factoryStatus');
        const finalProduct = document.getElementById('finalProduct');
        const nodeModal = document.getElementById('nodeModal');
        const modalContent = document.getElementById('modalContent');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const closeModal = document.getElementById('closeModal');
        const stageTimeline = document.getElementById('stageTimeline');

        // --- D3.JS VISUALIZATION SETUP ---
        let simulation, svg, g;
        let width = factoryFloor.clientWidth;
        let height = factoryFloor.clientHeight;

        function initializeVisualization() {
            if (svg) svg.remove();
            
            width = factoryFloor.clientWidth;
            height = factoryFloor.clientHeight;

            svg = d3.select("#factoryFloor").append("svg")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("viewBox", `0 0 ${width} ${height}`);
            
            svg.append("rect")
                .attr("x", width - 120)
                .attr("y", 10)
                .attr("width", 110)
                .attr("height", height - 20)
                .attr("rx", 10)
                .attr("fill", "rgba(0,0,0,0.2)")
                .attr("stroke", "#4b5563")
                .attr("stroke-dasharray", "5,5");

            svg.append("text")
                .attr("x", width - 65)
                .attr("y", 35)
                .attr("text-anchor", "middle")
                .attr("fill", "#9ca3af")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .text("Agent Pool");

            g = svg.append("g");

            drawAgentPool();
        }
        
        function drawAgentPool() {
            const agentGroup = g.append("g").attr("class", "agent-pool");
            AGENT_POOL.forEach((agent, i) => {
                const isMaestro = agent.id === 'Maestro';
                const agentX = isMaestro ? 50 : width - 65;
                const agentY = isMaestro ? 50 : 80 + i * 50;
                agent.homeX = agentX;
                agent.homeY = agentY;
                const agentNode = agentGroup.append("g")
                    .attr("id", `agent-${agent.id}`)
                    .attr("transform", `translate(${agentX}, ${agentY})`)
                    .style("cursor", "pointer");
                agentNode.append("circle").attr("r", 20).attr("fill", isMaestro ? "#3b82f6" : "#1f2937").attr("stroke", "#9ca3af").attr("class", "agent-circle");
                agentNode.append("g").attr("class", "agent-icon").html(agent.icon).attr("transform", "translate(-12, -12) scale(1)");
                agentNode.append("title").text(`${agent.role} (${agent.type})`);
            });
        }

        function updateGraph(graph) {
            const link = g.selectAll(".link").data(
                graph.links,
                d => `${d.source.id || d.source}-${d.target.id || d.target}`
            );
            const linkSelection = link.join("line").attr("class", "link").attr("stroke-width", 2);
            const node = g.selectAll(".node").data(graph.nodes, d => d.id);
            const nodeEnter = node.enter()
                .append("g")
                .attr("class", "node")
                .on("click", (event, d) => showNodeDetails(d))
                .call(drag(simulation));
            nodeEnter.append("circle")
                .attr("r", 25)
                .attr("id", d => `node-${d.id.replace(/\s|:/g, '-')}`)
                .style("stroke", "#9ca3af")
                .style("stroke-width", 2);
            nodeEnter.append("text")
                .attr("dy", 4)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .style("font-size", "10px");
            node.merge(nodeEnter).select("circle").style("fill", d => getNodeColor(d.status));
            node.merge(nodeEnter).select("text").text(d => d.id.length > 8 ? d.id.substring(0, 7) + '...' : d.id);
            node.exit().remove();
            simulation.nodes(graph.nodes).on("tick", ticked);
            simulation.force("link").links(graph.links);
            simulation.alpha(1).restart();
            function ticked() {
                linkSelection.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                g.selectAll(".node").attr("transform", d => `translate(${d.x},${d.y})`);
            }
        }
        
        function getStageXPosition(stageId) {
            const minX = 140;
            const maxX = width - 260;
            const defaultX = (minX + maxX) / 2;

            // If maestro.stageOrder is not available or is empty, fall back to a
            // deterministic position based on stageId so nodes don't all overlap.
            if (!maestro || !Array.isArray(maestro.stageOrder) || maestro.stageOrder.length === 0) {
                if (!stageId) {
                    return defaultX;
                }
                // Simple deterministic hash of the stageId string.
                let hash = 0;
                for (let i = 0; i < stageId.length; i++) {
                    hash = ((hash << 5) - hash) + stageId.charCodeAt(i);
                    hash |= 0; // Convert to 32-bit integer
                }
                const normalized = (Math.abs(hash) % 1000) / 999; // 0..1
                return minX + normalized * (maxX - minX);
            }

            const stageCount = maestro.stageOrder.length;
            const rawIndex = maestro.stageOrder.indexOf(stageId);
            const index = rawIndex >= 0 ? rawIndex : 0;
            const step = stageCount > 1 ? (maxX - minX) / (stageCount - 1) : 0;
            return minX + index * step;
        }

        function setupSimulation() {
            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(120))
                .force("charge", d3.forceManyBody().strength(-400))
                .force("x", d3.forceX(d => {
                    if (d.type === 'control') {
                        return d.id === 'Start' ? 100 : width - 250;
                    }
                    if (d.stage) {
                        return getStageXPosition(d.stage);
                    }
                    return width / 2;
                }).strength(0.5))
                .force("y", d3.forceY(height / 2).strength(0.1));
        }

        function drag(simulation) {
            function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
            function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        function getNodeColor(status) {
            switch (status) {
                case 'pending': return '#4b5563';
                case 'active': return '#2563eb';
                case 'complete': return '#16a34a';
                case 'failed': return '#dc2626';
                default: return '#4b5563';
            }
        }

        function renderRoleCards(docType) {
            const roles = ROLE_DEFINITIONS[docType] || ROLE_DEFINITIONS.default;
            roleDelineation.innerHTML = `
                <h3 class="text-lg font-semibold mb-3 text-gray-200">Who Does What?</h3>
                <div class="space-y-2">${roles.map(role => `
                    <div class="flex items-start gap-3 bg-gray-800/60 p-3 rounded-md border border-gray-700">
                        <div class="h-8 w-8 flex items-center justify-center rounded-full bg-blue-900/40 text-blue-300 font-semibold">${role.title[0]}</div>
                        <div>
                            <p class="text-sm text-white font-semibold">${role.title}</p>
                            <p class="text-xs text-gray-300">${role.bullet}</p>
                        </div>
                    </div>`).join('')}</div>`;
        }

        function renderChecklist(items) {
            const statusColors = { pending: 'bg-gray-700 text-gray-200', active: 'bg-yellow-900 text-yellow-200', complete: 'bg-green-900 text-green-200' };
            researchChecklist.innerHTML = `
                <h3 class="text-lg font-semibold mb-3 text-gray-200">Production Checklist</h3>
                <div class="space-y-2">${items.map(item => `
                    <div class="p-3 rounded-md border border-gray-700 bg-gray-800/70">
                        <div class="flex items-center justify-between">
                            <p class="text-sm text-white font-semibold">${item.label}</p>
                            <span class="text-[10px] px-2 py-1 rounded ${statusColors[item.status] || statusColors.pending}">${item.status.toUpperCase()}</span>
                        </div>
                        <p class="text-xs text-gray-400 mt-1">Source: ${item.source}</p>
                        ${item.note ? `<p class="text-[11px] text-blue-200 mt-1">${item.note}</p>` : ''}
                    </div>`).join('')}</div>`;
        }

        function renderStageTimeline(stages) {
            const statusClasses = {
                pending: 'border-gray-700 text-gray-300 bg-gray-900/60',
                active: 'border-yellow-500 text-yellow-200 bg-yellow-900/30',
                complete: 'border-green-500 text-green-200 bg-green-900/30'
            };
            stageTimeline.innerHTML = stages.map(stage => {
                const statusClass = statusClasses[stage.status] || statusClasses.pending;
                return `<div class="border ${statusClass} rounded-md p-2 text-[11px] leading-snug">
                    <p class="font-semibold">${stage.id}</p>
                    <p class="text-[10px] text-gray-400">${stage.description}</p>
                </div>`;
            }).join('');
        }
        
        // --- APPLICATION LOGIC ---
        class MaestroOrchestrator {
            constructor() {
                this.state = {};
                this.graph = { nodes: [], links: [] };
                this.isRunning = false;
                this.jobId = null;
                this.pollTimer = null;
                this.stages = [];
                this.checklist = [];
                this.sectionIds = [];
                this.stageOrder = [];
                this.template = null;
                this.pollInterval = 5000; // 5 seconds default
                this.consecutiveErrors = 0;
                this.maxConsecutiveErrors = 5;
            }

            preFlight(prompt, docType) {
                this.state = {
                    prompt,
                    docType,
                    keyFactors: this.deconstructPrompt(prompt, docType),
                    session_id: `session_${new Date().getTime()}`
                };
                renderRoleCards(docType);
                this.displayBlueprint();
                if (!this.template) {
                    this.displayInstructionPlaceholder();
                    renderStageTimeline([]);
                    renderChecklist([]);
                }
            }

            resetJobData() {
                this.jobId = null;
                this.template = null;
                this.stages = [];
                this.checklist = [];
                this.sectionIds = [];
                this.stageOrder = [];
                this.graph = { nodes: [], links: [] };
                finalProduct.innerHTML = '';
                updateGraph(this.graph);
            }

            deconstructPrompt(prompt, docType) {
                const docLabel = DOC_TYPE_LABELS[docType] || docType;
                const factors = {
                    docType: { text: docLabel, class: 'factor-doc' },
                    keyFactor: null,
                    subKeyFactors: []
                };

                // This is a rule-based engine. A real system would use an LLM call.
                const keyFactorRegex = /(?:for|on|about)\s(.*?)(?:that|which|alleging|focusing)/i;
                const subKeyFactorRegex = /(?:targeting|against|involving|focusing on)\s(.*?)(?:,|$)/gi;

                let keyFactorMatch = prompt.match(keyFactorRegex);
                if (keyFactorMatch && keyFactorMatch[1]) {
                    factors.keyFactor = { text: keyFactorMatch[1].trim().replace(/,$/, ''), class: 'factor-key' };
                }

                let subKeyMatch;
                while ((subKeyMatch = subKeyFactorRegex.exec(prompt)) !== null) {
                    factors.subKeyFactors.push({ text: subKeyMatch[1].trim().replace(/,$/, ''), class: 'factor-subkey' });
                }

                return factors;
            }

            displayBlueprint() {
                const { prompt, keyFactors } = this.state;
                let highlightedPrompt = prompt || 'Enter a prompt to define your document.';

                if (keyFactors.keyFactor) {
                    highlightedPrompt = highlightedPrompt.replace(
                        keyFactors.keyFactor.text,
                        `<span class="${keyFactors.keyFactor.class}">${keyFactors.keyFactor.text}</span>`
                    );
                }
                keyFactors.subKeyFactors.forEach(f => {
                    highlightedPrompt = highlightedPrompt.replace(f.text, `<span class="${f.class}">${f.text}</span>`);
                });
                highlightedPrompt = highlightedPrompt.replace(
                    new RegExp(keyFactors.docType.text, 'i'),
                    `<span class="${keyFactors.docType.class}">${keyFactors.docType.text}</span>`
                );

                deconstructedPrompt.innerHTML = highlightedPrompt;
            }

            getStageForNode(node) {
                return node.stage || null;
            }

            displayInstructionPlaceholder() {
                instructionBox.innerHTML = `
                    <h3 class="text-lg font-semibold mb-2 text-gray-200">Instructions</h3>
                    <p class="text-xs text-gray-400">Start production to load pipeline instructions and section knobs.</p>
                `;
            }

            displayInstructionBox(template) {
                if (!template) {
                    this.displayInstructionPlaceholder();
                    return;
                }
                const knobsHTML = Object.entries(template.knobs).map(([knobName, options]) => `
                    <div class="flex-1">
                        <label class="block text-xs font-medium text-gray-400 mb-1">${knobName}</label>
                        <select class="knob-select w-full bg-gray-800 border border-gray-600 text-white rounded-md px-2 py-1 text-xs focus:outline-none focus:ring-1 focus:ring-blue-500">
                            ${options.map(opt => `<option>${opt}</option>`).join('')}
                        </select>
                    </div>
                `).join('');

                instructionBox.innerHTML = `
                    <h3 class="text-lg font-semibold mb-2 text-gray-200">Instructions</h3>
                    <p class="text-xs text-gray-400 mb-3">Standard sections for a ${template.name}: <br/> <span class="text-gray-300">${template.sections.join(', ')}</span></p>
                    <p class="text-xs text-gray-400 mb-3">Shotlist Agent consumes OCR text and uploaded materials to create a fact-first outline before research deep-dives.</p>
                    <div class="flex gap-2">${knobsHTML}</div>
                `;
            }

            buildGraphFromJob(jobData) {
                const nodes = jobData.tasks.map(task => {
                    const agent = AGENT_POOL.find(a => a.id === task.agent_id);
                    return {
                        id: task.id,
                        status: task.status,
                        type: task.type,
                        agentId: task.agent_id,
                        agent: agent,
                        stage: task.stage,
                        output: task.output
                    };
                });
                const links = jobData.links.map(link => ({ source: link.source, target: link.target }));
                this.graph = { nodes, links };
            }

            applyJobUpdate(jobData) {
                this.stages = jobData.stages;
                this.checklist = jobData.checklist;
                this.stageOrder = jobData.stages.map(stage => stage.id);
                renderStageTimeline(this.stages);
                renderChecklist(this.checklist);
                this.graph.nodes.forEach(node => {
                    const task = jobData.tasks.find(item => item.id === node.id);
                    if (task) {
                        node.status = task.status;
                        node.output = task.output;
                        node.agentId = task.agent_id;
                        node.stage = task.stage;
                        node.agent = AGENT_POOL.find(agent => agent.id === task.agent_id);
                    }
                });
                updateGraph(this.graph);
                const activeTask = jobData.tasks.find(task => task.status === 'active' && task.type !== 'control');
                if (activeTask) {
                    const agent = AGENT_POOL.find(item => item.id === activeTask.agent_id);
                    factoryStatus.textContent = `STATUS: ${agent?.role || 'Agent'} is working on ${activeTask.id}...`;
                } else if (jobData.status === 'complete') {
                    factoryStatus.textContent = "STATUS: COMPLETE";
                } else {
                    factoryStatus.textContent = "STATUS: RUNNING";
                }
                if (jobData.status === 'complete') {
                    this.isRunning = false;
                    startButton.disabled = false;
                    startButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    this.stopPolling();
                }
            }

            applySectionsUpdate(sections) {
                finalProduct.innerHTML = sections.map(section => `
                    <div class="bg-gray-900/70 p-4 rounded-lg border border-gray-700 ${section.status === 'complete' ? 'animate-fade-in' : ''}">
                        <div class="flex items-center justify-between mb-2">
                            <h4 class="font-bold text-md text-blue-300">${section.title}</h4>
                            <span class="text-[10px] px-2 py-1 rounded ${section.status === 'complete' ? 'bg-green-900 text-green-200' : 'bg-gray-700 text-gray-200'}">
                                ${section.status.toUpperCase()}
                            </span>
                        </div>
                        <p class="text-gray-300 text-sm">${section.content || 'Drafting in progress...'}</p>
                    </div>
                `).join('');
            }

            loadJob(jobData) {
                this.jobId = jobData.id;
                this.template = jobData.template;
                this.sectionIds = jobData.template.sections;
                this.displayInstructionBox(jobData.template);
                this.buildGraphFromJob(jobData);
                this.applyJobUpdate(jobData);
            }

            async refreshJob() {
                if (!this.jobId) {
                    return;
                }
                try {
                    const jobData = await apiFetchJob(this.jobId);
                    this.applyJobUpdate(jobData);
                    const sectionData = await apiFetchSections(this.jobId);
                    this.applySectionsUpdate(sectionData.sections);
                    this.consecutiveErrors = 0; // Reset error count on success
                } catch (error) {
                    this.consecutiveErrors++;
                    console.error(`Error refreshing job (attempt ${this.consecutiveErrors}):`, error);
                    factoryStatus.textContent = `STATUS: ERROR FETCHING JOB (${error.message})`;
                    
                    // Stop polling after too many consecutive errors
                    if (this.consecutiveErrors >= this.maxConsecutiveErrors) {
                        console.error(`Stopping polling after ${this.maxConsecutiveErrors} consecutive errors`);
                        this.stopPolling();
                        this.isRunning = false;
                        startButton.disabled = false;
                        startButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                    throw error;
                }
            }

            startPolling() {
                this.stopPolling();
                this.consecutiveErrors = 0;
                this.pollTimer = setInterval(() => {
                    this.refreshJob().catch(() => {
                        // Error already handled in refreshJob (displays status,
                        // increments counter, stops polling after max retries)
                    });
                }, this.pollInterval);
            }

            stopPolling() {
                if (this.pollTimer) {
                    clearInterval(this.pollTimer);
                    this.pollTimer = null;
                }
            }

            async startProduction() {
                if (this.isRunning) return;
                if (!this.state.prompt) {
                    factoryStatus.textContent = "STATUS: ENTER A PROMPT TO START";
                    return;
                }
                
                // Immediately disable button and set running flag to prevent race conditions
                this.isRunning = true;
                startButton.disabled = true;
                startButton.classList.add('opacity-50', 'cursor-not-allowed');
                factoryStatus.textContent = "STATUS: STARTING";
                finalProduct.innerHTML = '';
                
                try {
                    const jobData = await apiCreateJob({
                        prompt: this.state.prompt,
                        doc_type: this.state.docType
                    });
                    this.loadJob(jobData);
                    this.startPolling();
                } catch (error) {
                    console.error("Error starting production:", error);
                    factoryStatus.textContent = `STATUS: ERROR STARTING JOB - ${error.message}`;
                    this.isRunning = false;
                    startButton.disabled = false;
                    startButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
        }
        
        const maestro = new MaestroOrchestrator();

        // --- UI EVENT LISTENERS ---
        docTypeSelector.addEventListener('change', (e) => {
            // Clear prompt when changing document type to avoid reusing a prompt
            // intended for a different document configuration
            promptInput.value = '';
            maestro.resetJobData();
            maestro.preFlight('', e.target.value);
        });
        promptInput.addEventListener('input', (e) => {
            maestro.preFlight(e.target.value, docTypeSelector.value);
        });
        startButton.addEventListener('click', () => {
             maestro.startProduction();
        });
        closeModal.addEventListener('click', hideNodeDetails);
        nodeModal.addEventListener('click', (e) => { if (e.target.id === 'nodeModal') hideNodeDetails(); });

        function showNodeDetails(nodeData) {
            modalTitle.textContent = `Task: ${nodeData.id}`;
            modalBody.innerHTML = `
                <div class="space-y-4 font-mono text-sm">
                    <div><p class="text-gray-400 uppercase tracking-wider text-xs">Status</p><p class="text-lg font-semibold" style="color: ${getNodeColor(nodeData.status)}">${nodeData.status.toUpperCase()}</p></div>
                    <div><p class="text-gray-400 uppercase tracking-wider text-xs">Assigned Agent</p><p>${nodeData.agent?.role || 'N/A'}</p></div>
                    <div><p class="text-gray-400 uppercase tracking-wider text-xs">Generated Output</p><pre class="bg-gray-900 p-3 rounded-md whitespace-pre-wrap">${nodeData.output || 'No output yet.'}</pre></div>
                </div>`;
            nodeModal.classList.remove('hidden');
            setTimeout(() => {
                nodeModal.classList.remove('opacity-0');
                modalContent.classList.remove('scale-95');
            }, 10);
        }

        function hideNodeDetails() {
            nodeModal.classList.add('opacity-0');
            modalContent.classList.add('scale-95');
            setTimeout(() => { nodeModal.classList.add('hidden'); }, 250);
        }

        // --- INITIALIZATION ---
        window.addEventListener('load', () => {
            initializeVisualization();
            setupSimulation();
            const initialPrompt = promptInput.value ? promptInput.value.trim() : '';
            if (initialPrompt !== '') {
                maestro.preFlight(initialPrompt, docTypeSelector.value);
            }
        });
        
        window.addEventListener('resize', () => {
            initializeVisualization();
            setupSimulation();
            if(maestro.graph.nodes.length > 0) {
                 updateGraph(maestro.graph);
            }
        });
    </script>
    <style>
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in { animation: fade-in 0.5s ease-out forwards; }
    </style>
</body>
</html>
