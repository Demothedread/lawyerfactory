"""
# Script Name: file_storage.py
# Description: Compatibility wrapper - imports from new location This file maintains backward compatibility during refactoring
# Relationships:
#   - Entity Type: Module
#   - Directory Group: Storage
#   - Group Tags: null
Compatibility wrapper - imports from new location
This file maintains backward compatibility during refactoring
"""
import importlib
import logging
import sys
from pathlib import Path

logger = logging.getLogger(__name__)

# Ensure src/ is on sys.path so imports like `from storage.api.file_storage import *` work
try:
    project_root = Path(__file__).resolve().parent.parent
    src_root = project_root / 'src'
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))
    if src_root.exists() and str(src_root) not in sys.path:
        sys.path.insert(0, str(src_root))
except Exception as e:
    logger.warning("Could not determine project root for file-storage compatibility: %s", e)

file_storage = None

# Try importing the refactored module first, then the legacy path. Avoid hard-failing if optional deps (like qdrant_client) are missing.
for candidate in ("src.storage.api.file_storage", "storage.api.file_storage"):
    try:
        file_storage = importlib.import_module(candidate)
        logger.info("Loaded file storage module: %s", candidate)
        break
    except ModuleNotFoundError as mnfe:
        # If the missing module is a transitive dependency like qdrant_client, log and continue to fallback
        logger.debug("Module not found while importing %s: %s", candidate, mnfe)
    except Exception as e:
        logger.exception("Unexpected error importing %s: %s", candidate, e)

if file_storage is None:
    logger.warning("File storage compatibility module not available; using minimal local fallback")

    class LocalFileStorageFallback:
        """Minimal local filesystem fallback for projects without the optional file-storage backend.
        Provides a small subset of the API expected by the rest of the application: save_file, list_files, get_file_path.
        """

        def __init__(self, uploads_dir: str = "uploads"):
            self.uploads_dir = Path(uploads_dir)
            try:
                self.uploads_dir.mkdir(parents=True, exist_ok=True)
            except Exception:
                pass

        def save_file(self, source_path: str, dest_name: str) -> str:
            # copy or move the file; keep simple and return path string
            src = Path(source_path)
            dest = self.uploads_dir / dest_name
            try:
                if src.exists():
                    data = src.read_bytes()
                    dest.write_bytes(data)
                    return str(dest.resolve())
            except Exception as e:
                logger.exception("Failed to save file to local storage fallback: %s", e)
            raise RuntimeError("Failed to save file in local fallback")

        def list_files(self) -> list:
            try:
                return [str(p) for p in sorted(self.uploads_dir.iterdir()) if p.is_file()]
            except Exception:
                return []

        def get_file_path(self, filename: str) -> str:
            p = self.uploads_dir / filename
            return str(p.resolve()) if p.exists() else ""

    file_storage = LocalFileStorageFallback()

# Expose a simple compatible API for callers that expect functions/attributes
try:
    # If loaded module provides a class or functions, expose them accordingly
    if hasattr(file_storage, "save_file"):
        save_file = file_storage.save_file
    elif hasattr(file_storage, "FileStorage"):
        # instantiate the class if appropriate
        _fs = file_storage.FileStorage()
        save_file = _fs.save_file
    else:
        # final fallback to attribute error raising function
        def save_file(*args, **kwargs):
            raise RuntimeError("No file storage available")

    if hasattr(file_storage, "list_files"):
        list_files = file_storage.list_files
    else:
        def list_files():
            return []

    if hasattr(file_storage, "get_file_path"):
        get_file_path = file_storage.get_file_path
    else:
        def get_file_path(name: str):
            return ""
except Exception as e:
    logger.exception("Error exposing file storage API: %s", e)
    def save_file(*args, **kwargs):
        raise RuntimeError("No file storage available")
    def list_files():
        return []
    def get_file_path(name: str):
        return ""